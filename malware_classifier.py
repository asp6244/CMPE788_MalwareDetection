import torch
import torch.nn as nn
from torch.utils.data import Dataset, DataLoader
import numpy as np

from data_compilation import all_months

class MalwareModel(nn.Module):
    """ A simple fully-connected deep neural network """
    def __init__(self, input_dim, learning_rate, momentum, weight_decay, dropout_rate):
        super(MalwareModel, self).__init__()

        self.net = nn.Sequential(
            nn.Linear(input_dim, 1024),
            nn.Dropout(p=dropout_rate),
            nn.BatchNorm1d(1024),
            nn.Linear(1024, 512),
            nn.Dropout(p=dropout_rate),
            nn.BatchNorm1d(512),
            nn.Linear(512, 256),
            nn.Dropout(p=dropout_rate),
            nn.BatchNorm1d(256),
            nn.Linear(256, 128),
            nn.Dropout(p=dropout_rate),
            nn.BatchNorm1d(128),
            nn.Linear(128, 1, bias=False)
        )

        self.criterion = nn.BCEWithLogitsLoss()

        self.optimizer = torch.optim.SGD(self.parameters(), lr=learning_rate, momentum=momentum, weight_decay=weight_decay)
        # self.optimizer = torch.optim.Adam(self.parameters(), learning_rate)

    def forward(self, x):
        """ Given input of size (batch_size x input_dim), compute output of the network """
        return self.net(x)

    def calc_loss(self, pred, target):
        """ Calculate loss """
        return self.criterion(pred, target)


class MalwareDataset(Dataset):
    def __init__(self, params, gt):
        self.params = params
        self.gt = gt

    def __len__(self):
        return len(self.gt)

    def __getitem__(self, idx):
        return (self.params[idx], self.gt[idx])


def build_dataloader(X_train, y_train, batch_size):
    dataset = MalwareDataset(X_train, y_train)
    dataloader = DataLoader(dataset, batch_size=batch_size, shuffle=True)
    return dataloader


def build_dataloader_list(all_data, batch_size, train):
    # Initialize empty dataloader list
    dataloaders = [None] * len(all_months)
    for month in all_months:
        (X_train, y_train, X_test, y_test) = all_data[month]
        # Create testing DataLoader
        if train:
            dataloaders[month] = build_dataloader(X_train, y_train, batch_size)
        else:
            dataloaders[month] = build_dataloader(X_test, y_test, batch_size)

    return dataloaders


class ModelTrainer:
    def __init__(self, num_epochs, training_elements):
        self.train_loss = np.zeros(training_elements)
        self.train_acc = np.empty(training_elements)
        self.test_loss_2017 = np.empty(num_epochs + 1)
        self.test_acc_2017 = np.empty(num_epochs + 1)
        self.test_loss_2018 = np.empty((len(all_months), num_epochs + 1))
        self.test_acc_2018 = np.empty((len(all_months), num_epochs + 1))
        self.element = 0

    def train(self, e, model, train_dataloader, print_frequency, print_iterations, progress_bar, epoch_bar):
        # Train over entire training dataset
        cum_loss, cum_acc = 0, 0
        batch_num = 0
        first_element = self.element
        for (X, y) in train_dataloader:
            # Compute prediction, loss, and accuracy
            pred = model(X)
            loss = model.calc_loss(pred, y)
            cum_loss += loss.item()
            cum_acc += np.average(torch.round(torch.sigmoid(pred)).cpu() == y.cpu())

            # Backpropagation
            model.optimizer.zero_grad()
            loss.backward()
            model.optimizer.step()

            # Periodically save loss and accuracy
            if batch_num % print_frequency == 0:
                if batch_num != 0:
                    cum_loss /= print_frequency
                    cum_acc /= print_frequency
                if print_iterations == 0:
                    self.train_loss[self.element] = cum_loss
                    self.train_acc[self.element] = cum_acc
                    self.element += 1
                else:
                    self.train_loss[e * print_iterations + batch_num//print_frequency] = cum_loss
                    self.train_acc[e * print_iterations + batch_num//print_frequency] = cum_acc
                print(f"Batch: {batch_num:4d} - Training loss: {cum_loss:6.4f}, Training accuracy: {cum_acc*100:5.2f}%", end='\r')
                cum_loss, cum_acc = 0, 0

            progress_bar.update()
            epoch_bar.update()
            batch_num += 1

        if print_iterations == 0:
            avg_loss = np.average(self.train_loss[first_element : self.element])
            avg_acc = np.average(self.train_acc[first_element : self.element])
        else:
            avg_loss = np.average(self.train_loss[e*print_iterations : (e+1)*print_iterations-1])
            avg_acc = np.average(self.train_acc[e*print_iterations : (e+1)*print_iterations-1])

        return avg_loss, avg_acc

    def test_on_testing_set(self, e, model, test_dataloader_2017, test_dataloaders_2018, progress_bar):
        # Test using 2017 testing set
        cum_loss, cum_acc = 0, 0
        with torch.no_grad():
            for (X, y) in test_dataloader_2017:
                pred = model(X)
                cum_loss += model.calc_loss(pred, y).item()
                cum_acc += np.average(torch.round(torch.sigmoid(pred)).cpu() == y.cpu())
                progress_bar.update()
        self.test_loss_2017[e+1] = cum_loss/len(test_dataloader_2017)
        self.test_acc_2017[e+1] = cum_acc/len(test_dataloader_2017)

        # Test using 2018 testing set
        tot_loss, tot_acc = 0, 0
        for month in all_months:
            cum_loss, cum_acc = 0, 0
            with torch.no_grad():
                for (X, y) in test_dataloaders_2018[month]:
                    pred = model(X)
                    cum_loss += model.calc_loss(pred, y).item()
                    cum_acc += np.average(torch.round(torch.sigmoid(pred)).cpu() == y.cpu())
                    progress_bar.update()
            self.test_loss_2018[month][e+1] = cum_loss/len(test_dataloaders_2018[month])
            self.test_acc_2018[month][e+1] = cum_acc/len(test_dataloaders_2018[month])
            tot_loss += self.test_loss_2018[month][e+1]
            tot_acc += self.test_acc_2018[month][e+1]

        tot_loss /= len(all_months)
        tot_acc /= len(all_months)

        return tot_loss, tot_acc